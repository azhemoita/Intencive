# Вопросы и ответы

## Общая информация
Этот файл содержит список вопросов и моих ответов на них.

---

### 1. Назовите основные принципы ООП. Расскажите подробно о каждом.

**Ответ:**

Основне принципы ООП: 
* абстракция,
* инкапсуляция,
* наслелование, 
* полиморфизм.

**Абстракция** - это правильное разделение программы на объекты. Обычно любую большую программу можно десятками способов представить в виде взаимодействующих объектов. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.

**Инкапсуляция** - это сокрытие реализации. Целью инкапсуляции является улучшение качества взаимодействия между элементами за счёт их упрощения.  

**Наследование** - это специальное отношение между двумя классами. В программировании есть возможность создавать один класс на основе другого. Новый класс становится потомком (наследником) уже существующего. Когда класс содержит 80%-90% нужных нам данных и методов мы просто объявляем подходящий класс родителем нашего нового класса, и в новом классе автоматически появляются все данные и методы класса-родителя.

**Полиморфизм** - это то что позволяет единообразно обращаться к объектам различных классов. Полиморфизм описывает ситуацию, когда за одним интерфейсом скрываются разные реализации.

---

### 2. Расскажите про иерархию наследования. Подробно про методы класса object.

**Ответ:**

Класс Object имеет 6 групп методов:
**toString()** - возвращает строковое представление объекта.  
**hashCode(), equals()** - пара методов, которые используются для сравнения объектов.  
**getClass()** - возвращает специальный объект, который описывает текущий класс.  
**notify(), notifyAll(), wait(), wait(long timeout, int nanos), wait(long timeout)** - методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей.   
**finalize()** - метод позволяет освободить родные не-Java ресурсы: закрыть файлы, потоки и т.д..  
**clone()** - метод позволяет клонировать объект, создаёт дубликат объекта.

---

### 3. Что такое интерфейс, что такое абстрактный класс.

**Ответ:** 

**Интерфейс** - это контракт, который определяет набор абстрактных методов (методов без реализации), которые должны быть реализованы классами, которые его наследуют. Интерфейс поддерживает множественное наследование.  

**Абстрактный класс** - это класс, который может содержать как абстрактные (без реализации), так и конкретные методы. Может наследоваться только одним классом (одиночное наследование). Используется для общего функционала наследников.

---

### 4. Может ли интерфейс \ абстрактный класс иметь конструктор, поля, статические статические \ дефолтные методы.

**Ответ:**

Интерфейс может иметь: public static final поля и методы без реализации. Кроме дефолтного метода, где можно указать реализацию. Больше ничего интерфейс иметь не может.

Абстрактный класс может иметь всё что и обычный класс: конструктор, поля, методы и т.д., кроме дефолтных методов. Дефолтные методы служат для интерфейсов.

---

### 5. Что такое Enum , в чем отличие от класса, может ли иметь методы , конструкторы , наследоваться реализовывать интерфейсы.

**Ответ:** 

Enum (Enumeration) - это класс, который предоставляет ограниченный набор значений-объектов. Enum может иметь методы. У него есть несколько встроенных методов такие как, например, values() и ordinal(). Он может иметь методы и конструкторы. Enum может реализовывать интерфейсы, но не может наследоватсья.

---

### 6. Расскажите про модификаторы доступа, к чему они применяются.

**Ответ:**

Существуют 4 типа модификаторов доступа: _private_, _package-private_, _protected_ и _public_.

**private** - указывает на то что элемент доступен только внутри класса.  
**package-private** - модификатор по-умолчанию. Элемент доступен внутри пакета, где этот элемент находится.  
**protected** - указывает на доступность в пределах пакета и наследниках класса.  
**public** - досуп к элементу возможен из любого места.  

Модификаторы доступа применяются к таким элементам как: классы, поля и методы.

---

### 7. Расскажите про конструкторы , с какими модификаторами они применяются, могут ли они наследоваться \ переопреляться ?

**Ответ:**

Конструктор — это специальный метод, который вызывается при создании объекта класса для его инициализации.
Модификаторы: public, protected, private, package-private(default).  
Конструкторы не наследуются и не переопределяются, но могут вызываться из конструктора подкласса с помощью super().

---
### 8. Можно ли в классе заимплементить 2 интерфейса? А если в них один и тот же метод doSmth? Как он реализуется?

**Ответ:**

Да. Можно. Можно имплементить сколь угодно много интерфейсов.  
Если интерфейсы содержат метод с одинаковой сигнатурой (например, doSmth()), то класс должен реализовать этот метод один раз — это будет общая реализация для обоих интерфейсов.

---
### 9. Статический \ динамический полиморфизм.

**Ответ:**

Статический полиморфизм — это перегрузка методов (overloading), когда метод определяется во время компиляции по разным сигнатурам.

Динамический полиморфизм — это переопределение методов (overriding), когда выбор метода происходит во время выполнения с учетом типа объекта (принцип наследования).

---
### 10. Что является членами класса.

**Ответ:**

Членами класса являются:
* Поля (переменные класса)
* Методы
* Конструкторы
* Блоки инициализации
* Вложенные классы (внутренние, статические)
* Перечисления (enum)
* Аннотации

---
### 11. Расскажите подробно как переопределяются\ перегружаются методы классов наследников.

**Ответ:**

**Перегрузка (Overloading):**
Методы в одном классе имеют одинаковое имя, но разные сигнатуры (количество или тип параметров). Происходит во время компиляции.

**Переопределение (Overriding):**
Метод из родительского класса заменяется в классе-наследнике с той же сигнатурой. Должен иметь модификатор @Override. Происходит во время выполнения.

При переопределении:

* Доступность метода не может быть ниже, чем в родительском классе
* Нельзя переопределить private, static и final методы

---
### 12. Jvm, Jre, Jdk,

**Ответ:**

**JVM** - Java Virtual Machine. Виртуальная машина Java. **JVM** интерпретирует байт-код в машинный код.  
**JRE** - Java Runtime Environment. Среда выполнения Java. Внутри **JRE** есть **JVM** и так же есть **Java API** (библиотеки)    
**JDK** - Java Development Kit. Комплект средств разработки Java. Это главный компонент внутри которого есть **JRE**. Так же в **JDK** есть средства разработки: инструменты для компиляции и отладки.  


---
### 13. Расскажите что такое classpath java, общее правило именования пакетов java

**Ответ:**

**Classpath** — это путь к каталогам и JAR-файлам, где JVM ищет классы и ресурсы при выполнении программы. Устанавливается через переменную окружения или флаг `-cp`.

**Правило именования пакетов:**  
Имена пакетов пишутся в **нижнем регистре** и обычно начинаются с обратного доменного имени компании (например, `com.company.project`). Это обеспечивает уникальность пакетов.

---
### 14. Расскажите про интерфейсы Comparator, Comparable и их применение.

**Ответ:**

**Comparable** — интерфейс, определяющий метод `compareTo()`. Используется для естественной сортировки объектов (например, по возрастанию числовых значений или алфавиту). Класс сам реализует логику сравнения.

**Comparator** — интерфейс, определяющий метод `compare()`. Используется для создания внешних правил сортировки. Позволяет задавать несколько вариантов сортировки без изменения класса.

---
### 15. Расскажите про класс String, пул строк

**Ответ:**

**String** — неизменяемый (immutable) класс для работы со строками. Все методы, изменяющие строку, возвращают новый объект.

**Пул строк (String Pool)** — это область памяти в куче (Heap), где хранятся уникальные строковые литералы. Одинаковые строки используют одну область памяти, чтобы уменьшить расход ресурсов. Строки из пула создаются через литералы (`String s = "text"`), а через `new String()` — в куче вне пула.

---
### 16. Расскажите про варианты использования зарезервированных слов таких как super, this, class, instace of

**Ответ:**

- **super** — обращение к методам или конструкторам родительского класса.
- **this** — обращение к текущему объекту класса (полям, методам, конструкторам).
- **class** — получение объекта типа `Class` (например, `ClassName.class`).
- **instanceof** — проверка, является ли объект экземпляром указанного класса или интерфейса.

---
### 17. java массивы, к какому типу относится, какие есть особенности можно ли создать 0 длинны, могут ли расширяться.

**Ответ:**

**Массивы** в Java — это **объекты**.

**Особенности:**
- Хранят элементы одного типа.
- Фиксированный размер (не могут расширяться).
- Можно создать массив длиной **0**.
- Индексация начинается с **0**.
- Длина массива доступна через поле `length`.

---
### 18. Назовите этапы создания \запуска блоков\конструкторов класса при наследовании.

**Ответ:**

При создании объекта класса с наследованием выполняются:

1. **Статические блоки инициализации родительского класса** (один раз при загрузке класса).
2. **Статические блоки инициализации дочернего класса**.
3. **Нестатические блоки инициализации родительского класса**.
4. **Конструктор родительского класса**.
5. **Нестатические блоки инициализации дочернего класса**.
6. **Конструктор дочернего класса**.

---
### 19. Расскажите какое будет поведение если внутри цикла вызвать оператор break\continue.

**Ответ:**

- **`break`** — немедленно завершает выполнение текущего цикла и выходит из него.
- **`continue`** — прерывает текущую итерацию и переходит к следующей, не выполняя оставшийся код в теле цикла.

---
### 20. Что такое Generic

**Ответ:**

**Generic** — это обобщённый тип, позволяющий параметризовать классы, интерфейсы и методы, обеспечивая **безопасность типов** и **гибкость**.

**Особенности:**
- Позволяет работать с разными типами без приведения.
- Проверка типов происходит во время компиляции.
- Нельзя использовать примитивные типы (`int`, `double` и т. д.), только их обёртки (`Integer`, `Double`).

---
### 21. Расскажите про такое зарезервированное слово как final, к чему применяется как используется.

**Ответ:**

`final` — ключевое слово, используемое для ограничения изменений.

Применяется к:
- **Переменным** — значение нельзя изменить после инициализации.
- **Методам** — метод нельзя переопределить в наследниках.
- **Классам** — класс нельзя наследовать.

---
### 22. Рассказать про Optional

**Ответ:**

`Optional` — это обёртка для предотвращения `NullPointerException`. Используется для работы с возможным отсутствием значения.

**Основные методы:**
- `of(T value)` — создаёт `Optional` с указанным значением.
- `empty()` — создаёт пустой `Optional`.
- `ofNullable(T value)` — создаёт `Optional`, позволяя `null`.
- `isPresent()` — проверяет, есть ли значение.
- `orElse(T other)` — возвращает значение или замену, если `Optional` пуст.
- `ifPresent(Consumer<T> action)` — выполняет действие, если значение есть.

---
### 23. Что описывает и показывает Big O нотация как высчитывается , что фактически измеряется, привести примеры

**Ответ:**

**Big O** — нотация, описывающая **асимптотическую сложность** алгоритма, то есть, как изменяется время выполнения или потребление памяти при росте входных данных.

**Измеряет:**
- **Временную сложность** — сколько операций выполняется.
- **Пространственную сложность** — сколько памяти используется.

**Как высчитывается:**
- Анализируется количество операций в зависимости от размера входных данных `n`.
- Убираются константы и менее значимые члены.

**Примеры сложности:**
- `O(1)` — Константная (доступ к элементу массива).
- `O(log n)` — Логарифмическая (бинарный поиск).
- `O(n)` — Линейная (поиск в неотсортированном массиве).
- `O(n²)` — Квадратичная (двойной цикл, пузырьковая сортировка).
- `O(2^n)` — Экспоненциальная (решение задачи коммивояжёра).

---
### 24. Основные алгоритмы сортировки знать/поимать принцип работы

**Ответ:**

**Основные алгоритмы сортировки и их принципы работы:**

1. **Пузырьковая сортировка (`O(n²)`)** — проходит по массиву, меняя местами соседние элементы, если они в неправильном порядке.
2. **Сортировка вставками (`O(n²)`)** — каждый элемент вставляется в уже отсортированную часть массива.
3. **Сортировка выбором (`O(n²)`)** — находит минимальный элемент и ставит его в начало, затем повторяет для оставшейся части.
4. **Быстрая сортировка (`O(n log n)`)** — выбирается опорный элемент (pivot), массив делится на две части (меньше и больше pivot), затем рекурсивно сортируется.
5. **Сортировка слиянием (`O(n log n)`)** — массив рекурсивно делится пополам, сортируется и затем объединяется.
6. **Сортировка подсчётом (`O(n + k)`)** — подходит для чисел в ограниченном диапазоне, использует массив частот.
7. **Поразрядная сортировка (`O(nk)`)** — сортирует числа по разрядам (например, сначала по единицам, потом по десяткам).

---
### 25. пузырьковая сортировка, сложность, что по памяти

**Ответ:**

**Пузырьковая сортировка** — алгоритм, который последовательно сравнивает и меняет местами соседние элементы, если они в неправильном порядке. Проходы повторяются, пока массив не станет отсортированным.

**Сложность:**
- **Лучший случай (`O(n)`)** — если массив уже отсортирован.
- **Средний и худший случай (`O(n²)`)** — при несортированном массиве.

**Память:**
- Использует **`O(1)`** дополнительной памяти (сортировка **на месте**).
- Может быть оптимизирован за счёт флага проверки перестановок.

---
### 26. сортировка выбором, сложность, что по памяти

**Ответ:**

**Сортировка выбором** — алгоритм, который находит минимальный элемент в неотсортированной части массива и меняет его местами с текущим первым элементом. Повторяется для каждого следующего элемента.

**Сложность:**
- **Лучший, средний и худший случай:** `O(n²)`, так как всегда выполняется два вложенных цикла.

**Память:**
- Дополнительная память **`O(1)`** (сортировка **на месте**).
- Неустойчивый алгоритм (сохраняет ли относительный порядок одинаковых элементов зависит от реализации).

---
### 27. сортировка вставкой, сложность, что по памяти

**Ответ:**

**Сортировка вставками** — алгоритм, который последовательно берёт элементы и вставляет их в правильное место в уже отсортированной части массива.

**Сложность:**
- **Лучший случай (`O(n)`)** — если массив уже отсортирован.
- **Средний и худший случай (`O(n²)`)** — если массив изначально хаотичный.

**Память:**
- Требует **`O(1)`** дополнительной памяти (сортировка **на месте**).
- **Стабильная** (сохраняет относительный порядок одинаковых элементов).

---
### 28. быстрая сортировка, сложность, что по памяти

**Ответ:**

**Быстрая сортировка (QuickSort)** — рекурсивный алгоритм, выбирающий опорный элемент (pivot), разделяющий массив на две части (меньше и больше pivot) и рекурсивно сортирующий их.

**Сложность:**
- **Лучший и средний случай (`O(n log n)`)** — если разбиение сбалансированное.
- **Худший случай (`O(n²)`)** — если всегда выбирается наихудший pivot (например, минимальный или максимальный элемент в отсортированном массиве).

**Память:**
- В среднем **`O(log n)`** (из-за рекурсии, глубина стека вызовов).
- При неудачном разбиении может потребовать **`O(n)`** памяти.
- Можно реализовать **на месте (`O(1)`)**, если использовать "ломутиво" разбиение без дополнительных массивов.

---
### 29. сортировка слиянием, сложность, что по памяти

**Ответ:**

**Сортировка слиянием (MergeSort)** — рекурсивный алгоритм, который делит массив на две части, рекурсивно их сортирует, а затем **сливает** в отсортированный массив.

**Сложность:**
- **Лучший, средний и худший случай:** `O(n log n)`, так как массив всегда делится пополам и выполняется `O(n)` операций слияния.

**Память:**
- Требует **`O(n)`** дополнительной памяти, так как создаются временные массивы для слияния.
- **Стабильная** сортировка (сохраняет порядок одинаковых элементов).

---
### 30. жадный алгоритм

**Ответ:**

**Жадный алгоритм** — алгоритм, который на каждом шаге **выбирает локально оптимальное решение**, надеясь получить **глобально оптимальный результат**.

**Особенности:**
- Работает быстро (`O(n log n)` или `O(n)`).
- Не всегда даёт оптимальный результат.
- Используется, если **жадный выбор** ведёт к оптимальному решению.

**Примеры:**
- Задача о размене монет.
- Алгоритм Дейкстры (поиск кратчайшего пути).
- Задача о рюкзаке (в приближённой форме).

---
### 31. бинарный поиск

**Ответ:**

**Бинарный поиск** — алгоритм поиска элемента в **отсортированном** массиве, работающий по принципу **деления пополам**.

**Принцип работы:**
1. Берётся **средний** элемент массива.
2. Если искомый элемент **меньше** — поиск продолжается в левой половине.
3. Если **больше** — в правой половине.
4. Повторяется, пока не найден элемент или не останется элементов.

**Сложность:**
- **Средний и худший случай:** `O(log n)`.
- **Лучший случай:** `O(1)`, если элемент найден сразу.

**Память:**
- `O(1)`, если итеративный вариант.
- `O(log n)`, если рекурсивный (из-за глубины рекурсии).

---
### 32. Алгоритмы поиска пути: обход в глубину, обход в ширину

**Ответ:**

**Обход в глубину (DFS, Depth-First Search)**
- Использует **стек** (рекурсивный вызов или явный стек).
- Идёт по одному пути **как можно глубже**, затем возвращается.
- Хорош для поиска путей, топологической сортировки, лабиринтов.
- **Сложность:** `O(V + E)`, где `V` — вершины, `E` — рёбра.
- **Память:** `O(V)` (в худшем случае).

**Обход в ширину (BFS, Breadth-First Search)**
- Использует **очередь**.
- Посещает **всех соседей** перед переходом на следующий уровень.
- Хорош для поиска кратчайшего пути в невзвешенных графах.
- **Сложность:** `O(V + E)`.
- **Память:** `O(V)`, так как хранит все узлы текущего уровня.

---
### 33. какие структуры данных в знаете

**Ответ:**

Основные структуры данных:

1. **Линейные структуры:**
    - **Массив (Array)** — фиксированный размер, быстрый доступ по индексу `O(1)`.
    - **Список (List)** — динамическая структура, элементы могут добавляться/удаляться.
    - **Связанный список (LinkedList)** — узлы с указателями на следующий (и предыдущий) элемент, эффективное удаление/вставка `O(1)`.
    - **Стек (Stack)** — LIFO (последний вошёл — первый вышел), операции `push/pop` за `O(1)`.
    - **Очередь (Queue)** — FIFO (первый вошёл — первый вышел), `enqueue/dequeue` за `O(1)`.
    - **Двусторонняя очередь (Deque)** — позволяет добавлять и удалять элементы с обоих концов.

2. **Деревья:**
    - **Двоичное дерево (Binary Tree)** — каждый узел имеет максимум 2 потомка.
    - **Двоичное дерево поиска (BST)** — левый потомок меньше родителя, правый — больше.
    - **АВЛ-дерево** — самобалансирующееся BST, поддерживает `O(log n)` операции.
    - **Куча (Heap)** — структура для приоритетной очереди, `O(log n)` на вставку/удаление.

3. **Графы:**
    - **Неориентированный / ориентированный граф** — набор вершин и рёбер.
    - **Взвешенный граф** — рёбра имеют вес.
    - **Списки смежности / матрица смежности** — способы представления графов.

4. **Хеш-таблицы:**
    - **HashMap / HashSet** — быстрый доступ `O(1)`, но возможны коллизии.

5. **Специфические структуры:**
    - **Trie (префиксное дерево)** — эффективно хранит строки.
    - **Skip List** — список с уровнями, обеспечивающий логарифмический поиск.

---
### 34. массивы достоинства недостатки

**Ответ:**

**Достоинства массивов:**
- **Быстрый доступ по индексу (`O(1)`)**.
- **Эффективное использование памяти** (нет накладных расходов на указатели).
- **Локальность данных** (благодаря последовательному размещению в памяти).

**Недостатки массивов:**
- **Фиксированный размер** (нельзя динамически изменять).
- **Дорогие операции вставки/удаления (`O(n)`)**, так как приходится сдвигать элементы.
- **Неэффективность при больших объёмах данных**, если нужно часто менять размер.

---
### 35. связанные списки, достоинства недостатки временная сложность добавления/поиск/удаления элемента

**Ответ:**

**Достоинства связанных списков:**
- **Гибкость** — могут динамически изменять размер.
- **Быстрое добавление/удаление (`O(1)`)** в начало/конец (если есть указатель на нужный узел).
- **Эффективное использование памяти** при частых вставках/удалениях.

**Недостатки связанных списков:**
- **Медленный доступ к элементам (`O(n)`)** — требуется последовательный обход.
- **Дополнительные затраты памяти** на хранение указателей.
- **Неэффективность для кэширования** — из-за разбросанности данных в памяти.

**Временная сложность:**
- **Добавление:** `O(1)` (в начало/конец, если есть указатель).
- **Поиск:** `O(n)`.
- **Удаление:** `O(1)` (если известен узел), иначе `O(n)`.

---
### 36. стэк, достоинства недостатки временная сложность добавления/поиск/удаления элемента

**Ответ:**

**Стек (Stack)** — структура данных, работающая по принципу **LIFO** (последний вошёл — первый вышел).

**Достоинства:**
- **Быстрое добавление и удаление (`O(1)`)**.
- **Простота реализации** (обычно на основе массива или связанного списка).
- **Используется в рекурсии, обратном проходе, алгоритмах вычислений**.

**Недостатки:**
- **Ограниченный доступ** — можно работать только с вершиной.
- **Невозможность произвольного доступа (`O(n)` в худшем случае)**.
- **Ограниченный размер (если реализован на массиве)**.

**Временная сложность:**
- **Добавление (`push`)** — `O(1)`.
- **Удаление (`pop`)** — `O(1)`.
- **Поиск** — `O(n)`, так как нужно просматривать элементы сверху вниз.

---
### 37. очередь, достоинства недостатки временная сложность добавления/поиск/удаления элемента

**Ответ:**

**Очередь (Queue)** — структура данных, работающая по принципу **FIFO** (первый вошёл — первый вышел).

**Достоинства:**
- **Эффективное управление потоком данных** (очереди задач, обработка событий).
- **Быстрое добавление и удаление (`O(1)`)** при реализации на связном списке или циклическом массиве.

**Недостатки:**
- **Медленный поиск (`O(n)`)** — требуется линейный обход.
- **Ограниченный размер** (если реализована на статическом массиве).

**Временная сложность:**
- **Добавление (`enqueue`)** — `O(1)`.
- **Удаление (`dequeue`)** — `O(1)`.
- **Поиск** — `O(n)`, так как нужно просматривать элементы по порядку.

---
### 38. деревья достоинства недостатки временная сложность добавления/поиск/удаления элемента

**Ответ:**

**Дерево (Tree)** — иерархическая структура данных, где каждый узел имеет потомков.

**Достоинства:**
- **Эффективный поиск, вставка, удаление (`O(log n)`)** в сбалансированных деревьях.
- **Гибкость представления данных** (файловые системы, базы данных, парсеры).
- **Иерархическая организация** удобна для моделирования зависимостей.

**Недостатки:**
- **Неэффективность при несбалансированности** (может превратиться в список, `O(n)`).
- **Сложность реализации и балансировки** (например, AVL, красно-чёрные деревья).
- **Дополнительные затраты памяти** (хранение ссылок на потомков).

**Временная сложность (для сбалансированного дерева):**
- **Добавление:** `O(log n)`.
- **Поиск:** `O(log n)`.
- **Удаление:** `O(log n)`.

**Для несбалансированного дерева:**
- В худшем случае — `O(n)`, если дерево вырождается в список.

---
### 39. На какие основные группы можно поделить типы данных?

**Ответ:**

Типы данных можно поделить на **основные группы**:

1. **Примитивные (скалярные) типы** — хранят простые значения:
   - Целые числа (`int`, `long`, `short`, `byte`).
   - Числа с плавающей запятой (`float`, `double`).
   - Логический тип (`boolean`).
   - Символьный тип (`char`).

2. **Ссылочные (объектные) типы** — представляют объекты и структуры данных:
   - Классы (`String`, `Integer`, `List`, `Map` и др.).
   - Интерфейсы.
   - Массивы.

3. **Абстрактные структуры данных** — объединяют несколько значений:
   - Коллекции (`List`, `Set`, `Map`, `Queue`).
   - Деревья, графы, стеки, очереди.

4. **Пользовательские типы** — созданные разработчиком (`enum`, `record`, кастомные классы).

---
### 40. Какие примитивные типы вы знаете?

**Ответ:**

В Java есть **8 примитивных типов данных**:

1. **Целочисленные:**
   - `byte` (8 бит, от -128 до 127).
   - `short` (16 бит, от -32 768 до 32 767).
   - `int` (32 бита, от -2³¹ до 2³¹-1).
   - `long` (64 бита, от -2⁶³ до 2⁶³-1).

2. **Числа с плавающей запятой:**
   - `float` (32 бита, ~7 знаков после запятой).
   - `double` (64 бита, ~15 знаков после запятой).

3. **Другие:**
   - `char` (16 бит, символы в кодировке **UTF-16**).
   - `boolean` (1 бит, принимает `true` или `false`).

---
### 41. Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?

**Ответ:**

**Преобразование примитивных типов данных** бывает:

1. **Неявное (автоматическое, widening)** — выполняется, если новый тип **шире** старого (без потери данных):
   - `byte → short → int → long → float → double`.

2. **Явное (принудительное, narrowing)** — требуется приведение, так как возможна потеря данных:
   - `double → float → long → int → short → byte`.
   - Может привести к **усечению числа** или **переполнению**.

**Логический тип (`boolean`)**
- **Нельзя преобразовать** в другие примитивные типы и обратно.
- Для конвертации используются условные выражения (`boolean ? 1 : 0`).

---
### 42. Какими значениями инициализируются переменные по умолчанию?

**Ответ:**

В Java **переменные экземпляра класса** инициализируются **по умолчанию**:

- **Целочисленные типы** (_byte_, _short_, _int_, _long_) → **0**.
- **Числа с плавающей запятой** (_float_, _double_) → **0.0**.
- **Символьный тип** _char_ → _'\u0000'_ (нулевой символ).
- **Логический тип** _boolean_ → **false**.
- **Ссылочные типы** (_String_, _Array_, _Object_) → **null**.

**Локальные переменные** **не инициализируются** автоматически — их нужно присваивать перед использованием.

---
### 43. Как передается значение переменной (по ссылке/значению)?

**Ответ:**

В Java передача переменных зависит от их типа:

1. **Примитивные типы** (`int`, `double`, `boolean` и т. д.)
   - **Передаются по значению** (копируется само значение).
   - Изменения внутри метода **не влияют** на оригинальную переменную.

2. **Ссылочные типы** (объекты, массивы)
   - **Передаются по значению ссылки** (копируется ссылка на объект).
   - Изменение полей объекта **затрагивает оригинальный объект**, но **изменение самой ссылки не влияет** на оригинальную переменную.

---
### 44. Что вы знаете про классы обертки

**Ответ:**

**Классы-обёртки (Wrapper classes)** — это объектные аналоги примитивных типов в Java, находящиеся в пакете `java.lang`.

**Список классов-обёрток:**
- `Byte`, `Short`, `Integer`, `Long` — для целых чисел.
- `Float`, `Double` — для чисел с плавающей запятой.
- `Character` — для символов (`char`).
- `Boolean` — для логических значений.

**Особенности:**
- Обеспечивают работу с примитивами как с объектами.
- Используются в **коллекциях (`List`, `Map`, `Set`)**, так как они работают только с объектами.
- Поддерживают **автоупаковку (autoboxing)** и **автораспаковку (unboxing)** — автоматическое преобразование примитивов в обёртки и обратно.
- **Неизменяемы (immutable)**, то есть их значения нельзя изменить после создания.

---
### 45. Определение коллекции

**Ответ:**

**Коллекция (Collection)** — это структура данных, представляющая собой **контейнер для хранения группы объектов**.

**Особенности коллекций в Java:**
- Находятся в пакете `java.util`.
- Поддерживают динамическое изменение размера.
- Позволяют работать с различными структурами данных (списки, множества, очереди).

**Основные интерфейсы коллекций:**
- `List` (упорядоченные элементы, доступ по индексу) — `ArrayList`, `LinkedList`.
- `Set` (уникальные элементы) — `HashSet`, `TreeSet`.
- `Queue` (очереди, FIFO) — `LinkedList`, `PriorityQueue`.
- `Map` (пары "ключ-значение", не является `Collection`) — `HashMap`, `TreeMap`.

---
### 46. Преимущества использования коллекций

**Ответ:**

**Преимущества использования коллекций в Java:**

1. **Динамический размер** — в отличие от массивов, коллекции автоматически изменяют размер.
2. **Гибкость** — разные типы коллекций для различных задач (списки, множества, очереди, словари).
3. **Удобные методы** — добавление, удаление, сортировка, поиск и работа с элементами.
4. **Производительность** — оптимизированные структуры данных (`HashMap`, `TreeSet`, `LinkedList`).
5. **Типобезопасность** — использование **Generics** предотвращает ошибки типов.
6. **Стандартная реализация** — коллекции из `java.util` хорошо протестированы и оптимизированы.
7. **Поддержка потоков (stream API)** — удобная работа с данными в функциональном стиле.

---
### 47. Какие объекты можно хранить в коллекциях

**Ответ:**

В коллекциях Java можно хранить **любые объекты**, кроме примитивных типов (`int`, `double` и т. д.).

**Основные правила:**
- **Ссылочные типы** — можно хранить объекты классов (`String`, `Integer`, `CustomClass` и т. д.).
- **Примитивные типы нельзя хранить** напрямую, но можно использовать **обёртки** (`Integer`, `Double` и т. д.).
- **Объекты могут быть `null`**, но не во всех коллекциях (`TreeSet`, `TreeMap` не поддерживают `null`).
- **Для `Set` и `Map` (ключи)** важно правильно переопределять `equals()` и `hashCode()`.
- **Массивы и коллекции** могут хранить другие коллекции (вложенные структуры).

---
### 48. Иерархия коллекций

**Ответ:**

Иерархия коллекций в Java основана на интерфейсе **`Collection`**, который наследуется следующими основными структурами:

1. **`Collection<E>`** (базовый интерфейс для всех коллекций)
   - **`List<E>`** (упорядоченные, допускают дубликаты)
      - `ArrayList` — динамический массив.
      - `LinkedList` — двусвязный список.
      - `Vector` — устаревший, потокобезопасный.

   - **`Set<E>`** (уникальные элементы, без индексов)
      - `HashSet` — неупорядоченный, основан на `HashMap`.
      - `TreeSet` — отсортированный, основан на `TreeMap`.
      - `LinkedHashSet` — сохраняет порядок вставки.

   - **`Queue<E>`** (очереди, FIFO)
      - `PriorityQueue` — очередь с приоритетом.
      - `ArrayDeque` — двусторонняя очередь (Deque).

2. **`Map<K, V>`** (пары "ключ-значение", не `Collection`)
   - `HashMap` — неупорядоченный, быстрый доступ.
   - `TreeMap` — отсортированный.
   - `LinkedHashMap` — сохраняет порядок вставки.
   - `ConcurrentHashMap` — потокобезопасный.

**Общий принцип:** `Collection` → `List` | `Set` | `Queue` → реализации.

---
### 49. Отличия вектора от ArrayList

**Ответ:**

**Основные отличия `Vector` и `ArrayList`:**

1. **Потокобезопасность:**
   - `Vector` **синхронизирован** (подходит для многопоточной среды).
   - `ArrayList` **не синхронизирован** (быстрее в однопоточной среде).

2. **Производительность:**
   - `ArrayList` быстрее из-за отсутствия синхронизации.
   - `Vector` медленнее из-за `synchronized`-методов.

3. **Рост массива:**
   - `ArrayList` увеличивает размер на **50%** при нехватке места.
   - `Vector` увеличивает размер **в 2 раза**.

4. **Использование в современном коде:**
   - `ArrayList` **предпочтителен** в большинстве случаев.
   - `Vector` **устарел**, используется редко (рекомендуется `Collections.synchronizedList()` для потокобезопасности).

---
### 50. Что знаете об коллекциях типа List как доб. элемент\расширяется коллекция

**Ответ:**

**`List`** — упорядоченная коллекция, допускающая дубликаты и доступ по индексу.

**Добавление элементов:**
- `add(E element)` — добавляет элемент в конец списка.
- `add(int index, E element)` — вставляет элемент по индексу.
- `addAll(Collection<? extends E> c)` — добавляет все элементы из другой коллекции.

**Расширение коллекции:**
- В `ArrayList` при нехватке места **создаётся новый массив большего размера**, копируются элементы (`новый размер = старый + 50%`).
- В `LinkedList` **создаются новые узлы**, ссылки перенастраиваются (динамический размер).

**Основные реализации `List`:**
- `ArrayList` — массив, быстрый доступ `O(1)`, медленное удаление/вставка `O(n)`.
- `LinkedList` — двусвязный список, быстрая вставка/удаление `O(1)`, медленный доступ `O(n)`.

---
### 51. Что знаете об коллекциях типа Set

**Ответ:**

**`Set`** — коллекция, **не допускающая дубликатов** и не гарантирует порядок элементов (кроме некоторых реализаций).

### **Основные реализации `Set`:**
1. **`HashSet`**
   - Основан на `HashMap`.
   - **Неупорядоченный**, быстрые операции `O(1)`.
   - `null` разрешён.

2. **`LinkedHashSet`**
   - Наследует `HashSet`, но **сохраняет порядок вставки**.
   - Производительность чуть ниже, чем у `HashSet`.

3. **`TreeSet`**
   - Основан на `TreeMap` (красно-чёрное дерево).
   - **Отсортированный порядок**, `O(log n)` на операции.
   - **Не разрешает `null`**.

### **Добавление элементов:**
- `add(E e)` — добавляет элемент, если его нет.
- `addAll(Collection<? extends E> c)` — добавляет все элементы из другой коллекции.

### **Особенности `Set`:**
- Не имеет индексов (нельзя обратиться по `set.get(index)`).
- Для корректной работы важно переопределять `equals()` и `hashCode()`.

---
### 52. Что знаете об коллекциях типа Queue

**Ответ:**

**`Queue`** — коллекция, реализующая принцип **FIFO** (первый вошёл – первый вышел).

### **Основные реализации `Queue`:**
1. **`LinkedList`** (двусвязный список)
   - Может работать как `Queue` и `Deque`.
   - Позволяет `null`.
   - `O(1)` на добавление/удаление.

2. **`PriorityQueue`** (очередь с приоритетом)
   - Элементы **упорядочены** по приоритету (сортируются `Comparable`/`Comparator`).
   - **Не допускает `null`**.
   - `O(log n)` на добавление/удаление.

3. **`ArrayDeque`** (двусторонняя очередь)
   - Быстрее `Stack` для стека и `LinkedList` для очереди.
   - **Не допускает `null`**.
   - `O(1)` на добавление/удаление.

### **Основные методы `Queue`:**
- `offer(E e)` — добавляет элемент (без исключения при нехватке места).
- `poll()` — удаляет и возвращает **голову** (возвращает `null`, если очередь пуста).
- `peek()` — возвращает голову без удаления (`null`, если пуста).

### **Особенности `Queue`:**
- Подходит для **очередей задач**, буферов, графовых алгоритмов (BFS).
- Для потокобезопасности используются **`ConcurrentLinkedQueue`** или **`BlockingQueue`**.

---
### 53. Что знаете об коллекциях типа Map и их принципиальное отличие

**Ответ:**

**`Map`** — коллекция для хранения пар **"ключ-значение"**, где ключи **уникальны**.

### **Принципиальные отличия от `List` и `Set`**:
- **Нет индексов**, доступ к элементам осуществляется по **ключу**.
- **Ключи уникальны**, но значения могут **повторяться**.
- В отличие от `Set`, позволяет **ассоциировать** данные (ключ → значение).

### **Основные реализации `Map`:**
1. **`HashMap`**
   - Основан на **хеш-таблице**, не гарантирует порядок.
   - `O(1)` на основные операции.
   - **Допускает `null`** (и в ключах, и в значениях).

2. **`LinkedHashMap`**
   - Наследует `HashMap`, **сохраняет порядок вставки**.
   - Производительность чуть ниже, чем у `HashMap`.

3. **`TreeMap`**
   - Основан на **красно-чёрном дереве**, хранит ключи **отсортированными**.
   - `O(log n)` на основные операции.
   - **Не допускает `null` в ключах**.

4. **`ConcurrentHashMap`**
   - Потокобезопасный аналог `HashMap`, разделяет данные на сегменты.
   - Не допускает `null` в ключах.

### **Основные методы `Map`:**
- `put(K key, V value)` — добавить/обновить значение.
- `get(K key)` — получить значение по ключу.
- `remove(K key)` — удалить элемент.
- `containsKey(K key)` — проверить существование ключа.
- `keySet()` / `values()` / `entrySet()` — получить ключи/значения/пары.

---
### 54. Назовите основные реализации List,Set,Map

**Ответ:**

### **Основные реализации `List`** (упорядоченные, допускают дубликаты):
1. **`ArrayList`** — динамический массив, быстрый доступ `O(1)`, медленное удаление `O(n)`.
2. **`LinkedList`** — двусвязный список, медленный доступ `O(n)`, быстрое добавление/удаление `O(1)`.
3. **`Vector`** — устаревший, потокобезопасный, увеличивается в 2 раза.

### **Основные реализации `Set`** (не допускают дубликаты, нет индексов):
1. **`HashSet`** — основан на `HashMap`, порядок не гарантирован, `O(1)`.
2. **`LinkedHashSet`** — сохраняет порядок вставки, `O(1)`.
3. **`TreeSet`** — отсортирован, основан на `TreeMap`, `O(log n)`.

### **Основные реализации `Map`** (пары "ключ-значение", ключи уникальны):
1. **`HashMap`** — основан на хеш-таблице, порядок не гарантирован, `O(1)`.
2. **`LinkedHashMap`** — сохраняет порядок вставки, `O(1)`.
3. **`TreeMap`** — отсортирован по ключам, основан на красно-чёрном дереве, `O(log n)`.
4. **`ConcurrentHashMap`** — потокобезопасный `HashMap`, `O(1)`.

---
### 55. Что общего у ArrayList\LinkedList, когда какой лучше использовать

**Ответ:**

### **Общее у `ArrayList` и `LinkedList`**:
- Оба реализуют **`List`**, поддерживают **индексацию** и **дубликаты**.
- Оба являются **динамическими** (размер изменяется автоматически).
- Оба поддерживают основные операции (`add()`, `get()`, `remove()`).

### **Когда использовать `ArrayList`**:
**Быстрый доступ по индексу** (`O(1)`).  
**Идеален для частого чтения данных**.  
**Медленная вставка/удаление в середину** (`O(n)`, т. к. элементы сдвигаются).  
**Плохая производительность при частых изменениях размера**.

**Лучший выбор, если:**
- Преобладают **чтение и случайный доступ**.
- Мало **вставок/удалений** в середине.

### **Когда использовать `LinkedList`**:
**Быстрое добавление/удаление в начало и середину** (`O(1)`).  
**Подходит для реализации очередей и стеков**.  
**Медленный доступ по индексу** (`O(n)`, нужно проходить список).  
**Больше памяти из-за хранения ссылок между элементами**.

**Лучший выбор, если:**
- Часто требуется **вставка/удаление в середину или начало**.
- Нужен **двусвязный список**.

---
### 56. Расскажите про HashSet

**Ответ:**

**HashSet — реализация Set на основе HashMap**
- **Не допускает дубликатов** (уникальные элементы).
- **Не гарантирует порядок элементов**.
- **Разрешает `null`** (но только один раз).
- **Быстрые операции `add()`, `remove()`, `contains()` – O(1)** в среднем.

**Принцип работы:**
- Основан на хеш-таблице (HashMap).
- Элементы хранятся как **ключи в `HashMap`**, а в качестве значений используется заглушка.
- Для правильной работы **необходимо переопределять `hashCode()` и `equals()`**.

**Основные методы:**
- `add(E e)` — добавляет элемент (если уже есть, не изменяет `Set`).
- `remove(E e)` — удаляет элемент.
- `contains(E e)` — проверяет наличие.
- `size()` — возвращает количество элементов.
- `isEmpty()` — проверяет, пустой ли `Set`.

**Когда использовать HashSet?**  
* Когда важна уникальность элементов.  
* Когда не нужен порядок хранения.  
* Когда важна высокая скорость операций (**O(1)**).

---
### 57. Расскажите про TreeSet/ Как сортируются элементы

**Ответ:**

### **`TreeSet` — упорядоченное множество (`Set`) на основе `TreeMap`**
- **Элементы хранятся в отсортированном порядке** (по возрастанию).
- **Не допускает дубликатов**.
- **Не разрешает `null`**.
- **Медленнее `HashSet`**: операции `add()`, `remove()`, `contains()` выполняются за **`O(log n)`**.

### **Как сортируются элементы?**
1. **По естественному порядку (`Comparable`)**
   - Классы, реализующие `Comparable<T>`, сортируются по `compareTo()`.
   - Например, `Integer`, `String`, `Double` сортируются автоматически.

2. **С помощью `Comparator`**
   - Можно передать **свой компаратор** при создании `TreeSet`:
   - `TreeSet<>(Comparator<T>)` позволяет задать кастомное сравнение.

### **Основные методы:**
- `add(E e)` — добавляет элемент (если уже есть, не изменяет `Set`).
- `remove(E e)` — удаляет элемент.
- `first()` / `last()` — возвращает минимальный / максимальный элемент.
- `higher(E e)` / `lower(E e)` — находит ближайший **больший / меньший** элемент.
- `subSet(E from, E to)` — возвращает подмножество.

### **Когда использовать `TreeSet`?**
**Когда нужен `Set`, но с автоматической сортировкой**.  
**Когда важно быстро находить минимальные / максимальные значения**.  
**Когда важна максимальная скорость (т.к. `O(log n)`)**, лучше использовать `HashSet`.

---
### 58. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию

**Ответ:**

### **Задание порядка следования объектов в коллекции**
1. **Естественный порядок (`Comparable`)**
   - Класс должен **реализовать `Comparable<T>`** и переопределить метод `compareTo(T o)`.
   - Используется **по умолчанию** в `TreeSet`, `TreeMap`, `Collections.sort()`.

2. **Кастомный порядок (`Comparator`)**
   - Создаётся **отдельный класс, реализующий `Comparator<T>`**.
   - Передаётся в коллекции (`TreeSet`, `TreeMap`, `Collections.sort(list, comparator)`).

---

### **Как отсортировать коллекцию?**
1. **Сортировка `List`**
   - `Collections.sort(list)` — сортирует `List` по **естественному порядку (`Comparable`)**.
   - `Collections.sort(list, comparator)` — сортирует `List` по **кастомному `Comparator`**.
   - `list.sort(comparator)` — аналогичный метод для `List`.

2. **Сортировка `Set`**
   - `TreeSet` автоматически **сортирует элементы** по `Comparable` или `Comparator`.
   - `HashSet` **не поддерживает сортировку**, но можно перенести в `List` и отсортировать.

3. **Сортировка `Map` (по ключам или значениям)**
   - `TreeMap` хранит ключи **отсортированными**.
   - Для `HashMap` можно создать **`LinkedHashMap`**, отсортировав `entrySet()`.

### **Когда использовать?**
`Comparable` – если **у класса есть естественный порядок** (например, `String`, `Integer`).  
`Comparator` – если нужно **разные способы сортировки** без изменения класса.

---
### 59. Iterator. Как его получить(). Его методы что зачем

**Ответ:**

**`Iterator` — интерфейс для перебора элементов коллекции**
Позволяет **последовательно обходить** элементы **без доступа по индексу** (актуально для `Set`, `Map`).

**Как получить `Iterator`?**
```java
Iterator<T> iterator = collection.iterator();
```
- Работает для **`List`**, **`Set`**, **`Queue`**, **`Map` (через `entrySet()` или `keySet()`)**.

**Основные методы `Iterator`**
1. **`boolean hasNext()`** — проверяет, есть ли **следующий элемент**.
2. **`T next()`** — возвращает **следующий элемент**.
3. **`void remove()`** — **удаляет текущий элемент** (который вернул `next()`).
   - Работает **только после `next()`**.
4. **`forEachRemaining(Consumer<? super T> action)`** — выполняет **действие для оставшихся элементов**.

**Когда использовать `Iterator`:**  
- **Когда нет индексов** (`Set`, `Map`).  
- **Когда нужно безопасное удаление во время итерации** (`remove()`).  
- **Когда используется `ListIterator` для двустороннего обхода**.

---
### 60. Iterable что за зверь. Что за контракт описывает

**Ответ:**

**`Iterable` — базовый интерфейс для всех коллекций, поддерживающих итерацию**
- Определяет **"контракт"** для объектов, которые можно **перебирать в `for-each` цикле**.
- Находится в пакете `java.lang`, **реализуется `Collection` и её наследниками (`List`, `Set`, `Queue`)**.
- **Не содержит методов для добавления/удаления элементов** — только для **итерации**.

**Контракт `Iterable<T>`**
- Класс, реализующий `Iterable`, **должен предоставить метод `iterator()`**, который возвращает `Iterator<T>`.
- Это позволяет **использовать `for-each` для перебора элементов**.

**Основной метод `Iterable`**
1. **`Iterator<T> iterator()`** — возвращает **итератор** для обхода элементов.
Дополнительно (начиная с Java 8):
2. **`void forEach(Consumer<? super T> action)`** — выполняет действие для каждого элемента.
3. **`Spliterator<T> spliterator()`** — возвращает `Spliterator` для **параллельной обработки**.

**Когда использовать `Iterable`?**
**Когда нужно создать свой класс с возможностью `for-each` обхода**.  
**Когда разрабатываете собственные коллекции или структуры данных**.

---
### 61. Коллекция 10 элементов.Вызываю 9x Iterator.hasNext а затем Iterator.next.Что вернется

**Ответ:**

Допустим, у нас есть **коллекция из 10 элементов**, и мы вызываем **`Iterator.hasNext()` 9 раз**, а затем **`Iterator.next()`**.

**Что произойдёт?**
- **`hasNext()` просто проверяет**, есть ли **следующий элемент**, но **не сдвигает итератор**.
- После 9 вызовов `hasNext()`, итератор всё ещё **указывает на первый элемент**.
- Когда вызывается `next()`, **он вернёт первый элемент** и **сдвинет указатель** вперёд.

**Вывод:**
После **9 вызовов `hasNext()`** **ничего не изменится**, а первый вызов `next()` **вернёт первый элемент коллекции**.

---
### 62. Как перебрать все ключи значения Map (Можно ли через Iterable)

**Ответ:**

### **Как перебрать все ключи и значения `Map`?**
`Map<K, V>` **не реализует `Iterable` напрямую**, но его можно перебрать через `entrySet()`, `keySet()` или `values()`.

**1. Через `entrySet()` (лучший вариант, доступ к ключу и значению). Самый удобный и производительный способ.**
```java
for (Map.Entry<K, V> entry : map.entrySet()) {
    K key = entry.getKey();
    V value = entry.getValue();
}
```

**2. Через `keySet()` (только ключи, затем `get()` для значений).** Медленнее `entrySet()`, так как `get()` выполняется отдельно.
```java
for (K key : map.keySet()) {
    V value = map.get(key);
}
```

**3. Через `values()` (только значения)**
```java
for (V value : map.values()) {
    // Обрабатываем значения
}
```

**4. Через `Iterator` (если нужен полный контроль). Полезно, если нужно удалять элементы во время итерации (`iterator.remove()`)**.
```java
Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<K, V> entry = iterator.next();
}
```

**5. Через `forEach()` (Java 8+). Коротко и удобно, но нельзя удалять элементы**.
```java
map.forEach((key, value) -> {
    // Обработка key и value
});
```


**Вывод:**
- **Лучший вариант – `entrySet()` (доступ к ключам и значениям сразу)**.
- **Через `Iterable` напрямую нельзя, но `entrySet()`, `keySet()`, `values()` перебираются `for-each` циклом**.

---
### 63. Разница Iterator,Enumerator,ListIterator

**Ответ:**

**1. `Iterator`**
- Используется для **итерации по `Collection` (List, Set, Queue)**.
- **Методы:**
   - `hasNext()` — есть ли следующий элемент.
   - `next()` — получить следующий элемент.
   - `remove()` — удалить текущий элемент (⚠ только **один раз после `next()`**).
- **Однонаправленный** (идёт только **вперёд**).
- Нельзя изменять элементы (только удаление).

---

**2. `ListIterator` (расширение `Iterator` для `List`)**
- Работает **только с `List` (ArrayList, LinkedList)**.
- **Дополнительные возможности:**
   - `hasPrevious()` / `previous()` — можно **двигаться назад**.
   - `add(E e)` — добавляет элемент в список **во время итерации**.
   - `set(E e)` — изменяет **текущий элемент**.
- **Двунаправленный (вперёд и назад)**.
- Можно **изменять, добавлять и удалять** элементы.

---

**3. `Enumeration` (устаревший, используется в `Vector` и `Hashtable`)**
- Методы:
   - `hasMoreElements()` — аналог `hasNext()`.
   - `nextElement()` — аналог `next()`.
- **Только для устаревших классов (`Vector`, `Hashtable`)**.
- **Не поддерживает `remove()`**.

**Лучший вариант:**  
`Iterator` — универсальный, но без изменений.  
`ListIterator` — **если нужен доступ назад и модификация списка**.  
`Enumeration` — устаревший, **лучше не использовать**.

---
### 64. В каких случаях может быть выброшено ConcurrentModificationException

**Ответ:**

`ConcurrentModificationException` возникает, если:
1. **Изменяется коллекция во время итерации (for-each, `Iterator`)**.
2. **Удаляется элемент без `Iterator.remove()`**.
3. **Изменяется `Map` во время обхода `entrySet()`**.
4. **Коллекция (`ArrayList`, `HashMap`) изменяется из другого потока**.

Как избежать:
- Использовать `Iterator.remove()`.  
- Применять `CopyOnWriteArrayList`, `ConcurrentHashMap` для многопоточности.  
- Использовать `Stream API` вместо удаления в цикле.

---
### 65. Что такое Stream API?

**Ответ:**

Stream API — это инструмент для обработки коллекций в функциональном стиле.

**Особенности:**
- Позволяет **фильтровать, преобразовывать, сортировать, аггрегировать данные**.
- Поддерживает **ленивые вычисления** (операции выполняются только при вызове терминальной операции).
- Может работать в **параллельном режиме (`parallelStream()`)**.

**Основные типы операций:**
1. **Промежуточные (не изменяют исходный поток, создают новый):** `filter()`, `map()`, `sorted()`, `distinct()`.
2. **Терминальные (завершают поток):** `collect()`, `forEach()`, `count()`, `reduce()`.

**Преимущества:**
- Код становится **более читаемым и декларативным**.  
- Позволяет **уменьшить количество циклов**.  
- Поддерживает **многопоточность** (`parallelStream()`).

---
### 66. Каковы основные преимущества использования Stream API?

**Ответ:**

**Преимущества Stream API:**  
- **Краткость и читаемость** – упрощает работу с коллекциями, уменьшая количество циклов.  
- **Функциональный стиль** – код становится декларативным, описывает **что делать**, а не **как**.  
- **Ленивая обработка** – промежуточные операции выполняются только при вызове терминальной.  
- **Параллельность** – поддержка `parallelStream()`, что улучшает производительность на многопроцессорных системах.  
- **Меньше изменяемых данных** – операции не изменяют исходные коллекции, снижая вероятность ошибок.

---
### 67. Какие основные операции доступны в Stream API?

**Ответ:**

**Основные операции в Stream API:**

🔹 **Промежуточные (ленивые, создают новый поток):**
- `filter(Predicate)` – фильтрация элементов.
- `map(Function)` – преобразование элементов.
- `flatMap(Function)` – разворачивание вложенных структур.
- `sorted(Comparator)` – сортировка.
- `distinct()` – удаление дубликатов.
- `peek(Consumer)` – промежуточная обработка.
- `limit(long)` / `skip(long)` – ограничение и пропуск элементов.

🔹 **Терминальные (завершают поток):**
- `collect(Collector)` – сбор данных в коллекцию или строку.
- `forEach(Consumer)` – перебор элементов.
- `count()` – количество элементов.
- `reduce(BinaryOperator)` – агрегирование значений.
- `min(Comparator)` / `max(Comparator)` – поиск минимального/максимального элемента.
- `allMatch()`, `anyMatch()`, `noneMatch()` – проверки условий.

🔹 **Параллельная обработка:**
- `parallelStream()` – многопоточная обработка данных.

---
### 68. Как можно объединять несколько Stream с помощью Stream API?

**Ответ:**

Объединять несколько `Stream` можно с помощью:

**`Stream.concat(stream1, stream2)`** – объединяет два потока в один.  
**`Stream.of(stream1, stream2).flatMap(s -> s)`** – объединяет несколько потоков.  
**`Stream.builder().add(...).build()`** – создание объединённого потока вручную.  
**`Collectors.toList()` после `Stream` обработки** – если данные собираются в список, можно объединять через `addAll()`.

---
### 69. Как использовать Stream API для обработки ошибок?

**Ответ:**

В `Stream API` обработка ошибок возможна через:

**`filter()`** – исключение некорректных данных.  
**`try-catch` внутри `map()`** – обработка исключений при преобразовании.  
**Оборачивание в `Optional`** – избежание `NullPointerException`.  
**`collect()` с обработкой ошибок** – агрегация с кастомной логикой.  
**Логирование через `peek()`** – отслеживание ошибок в потоке.

---
### 70. Как использовать методы фильтрации в Stream API, что принимает/возвращает?

**Ответ:**

Методы фильтрации в `Stream API`:

**`filter(Predicate<T>)`** – принимает `Predicate<T>` (функцию, возвращающую `boolean`), оставляет только элементы, удовлетворяющие условию.  
**`distinct()`** – удаляет дубликаты, сравнивая элементы через `equals()`.  
**`limit(long n)`** – оставляет только первые `n` элементов.  
**`skip(long n)`** – пропускает первые `n` элементов.

Все методы возвращают **новый `Stream<T>`** без изменения исходных данных.

---
### 71. Как применять Collectors.groupingBy() Stream API, что принимает\возвращает?

**Ответ:**

`Collectors.groupingBy()` используется для группировки элементов в `Stream API`.

 **Принимает:**  
`Function<T, K>` – функцию, определяющую ключ для группировки.  
Опционально: `Collector` (например, `Collectors.counting()`, `Collectors.toList()`).

 **Возвращает:**  
`Map<K, List<T>>` (по умолчанию).  
`Map<K, Set<T>>`, `Map<K, Long>`, если используется другой `Collector`.

---
### 72. Как можно использовать Stream API для преобразования одного типа данных в другой, например int[] 1,2,3?

**Ответ:**

Для преобразования одного типа данных в другой через `Stream API` можно использовать:

**`map()`** – применяется для преобразования элементов (`stream.map(i -> String.valueOf(i))`).  
**`mapToInt()` / `mapToObj()` / `mapToDouble()`** – преобразование в другой примитивный или объектный тип.  
**`collect(Collectors.toList()/toSet()/toMap()`)** – сбор преобразованных данных в коллекции.  
**`boxed()`** – преобразует примитивные потоки (`IntStream`, `DoubleStream`) в объекты (`Stream<Integer>`, `Stream<Double>` и т. д.).

Пример:  
- `Arrays.stream(intArray).mapToObj(String::valueOf).collect(Collectors.toList())` – преобразует `int[]` в `List<String>`.

---
### 73. Отличия flatMap от map

**Ответ:**

- **`map(Function<T, R>)`** – применяет функцию к каждому элементу, возвращает `Stream<R>`. Используется для преобразования данных **один-к-одному**.

- **`flatMap(Function<T, Stream<R>>)`** – разворачивает вложенные структуры (`List<List<T>> → List<T>`), объединяя потоки в один. Используется для **один-ко-многим** преобразований.

---
### 74. Как работать с параллельными потоками с помощью Stream API?

**Ответ:**

Параллельные потоки в `Stream API` позволяют обрабатывать данные многопоточно.

 **Основные методы:**  
`parallelStream()` – создаёт параллельный поток.  
`stream().parallel()` – преобразует обычный поток в параллельный.  
`sequential()` – превращает параллельный поток обратно в последовательный.

 **Особенности:**  
Использует **ForkJoinPool** (разделение задач между потоками).  
Подходит для **больших объёмов данных**.  
Не гарантирует **сохранение порядка элементов**.  
Может привести к **race condition** при изменяемых данных.

---
### 75. Как использовать метод forEach в Stream API? - что принимает\возвращает?

**Ответ:**

 **`forEach(Consumer<T>)`** – терминальная операция, применяющая действие (`Consumer<T>`) к каждому элементу потока.  
 **Принимает:** лямбда-выражение или метод, выполняющий действие (`System.out::println`).  
 **Возвращает:** `void` (ничего не возвращает).  
 **Особенности:**  
Используется для побочных эффектов (вывод, логирование).  
В `parallelStream()` порядок обработки **не гарантируется**.  
Для сохранения порядка применяют `forEachOrdered()`.

---
### 76. Как использовать метод peek в Stream API? - что принимает\возвращает?

**Ответ:**

 **`peek(Consumer<T>)`** – промежуточная операция, выполняющая действие (`Consumer<T>`) для каждого элемента, не изменяя поток.  
 **Принимает:** лямбда-выражение или ссылку на метод (`System.out::println`).  
 **Возвращает:** новый `Stream<T>` с теми же элементами.  
 **Особенности:**  
Используется для **отладки** (`.peek(System.out::println)`).  
В отличие от `forEach()`, не завершает поток.  
Требует терминальной операции (`collect()`, `count()`) для выполнения.

---
### 77. Как работает метод reduce в Stream API? - что принимает\возвращает? Варианты методы

**Ответ:**

Метод **`reduce()`** выполняет **свертку элементов** в `Stream`, объединяя их в одно значение.

 **Варианты `reduce()`:**  
**`reduce(BinaryOperator<T> accumulator)`** – принимает бинарную функцию, возвращает `Optional<T>`.
- Пример: `stream.reduce((a, b) -> a + b)` (складывает элементы).

**`reduce(T identity, BinaryOperator<T> accumulator)`** – принимает начальное значение и бинарную функцию, возвращает `T`.
- Пример: `stream.reduce(0, Integer::sum)`.

**`reduce(U identity, BiFunction<U,? super T, U> accumulator, BinaryOperator<U> combiner)`** – поддерживает параллельные вычисления, возвращает `U`.
- Пример: `stream.parallel().reduce(0, Integer::sum, Integer::sum)`.

 **Используется для:**  
Агрегации данных (сумма, произведение, нахождение максимума/минимума).  
Редукции списка значений в одно (конкатенация строк, объединение коллекций).

---
### 78. Как создать бесконечный поток с помощью Stream API?

**Ответ:**

Бесконечные потоки в `Stream API` создаются с помощью:

**`Stream.generate(Supplier<T>)`** – генерирует элементы бесконечно.
- Пример: `Stream.generate(Math::random)`.

**`Stream.iterate(T seed, UnaryOperator<T>)`** – создаёт последовательность значений.
- Пример: `Stream.iterate(0, n -> n + 2)`.

 **Ограничение бесконечного потока:**  
Использовать `limit(n)`, чтобы сделать поток конечным.

---
### 79. Какие ограничения есть у Stream API?

**Ответ:**

 **Ограничения Stream API:**  
**Одноразовость** – поток можно использовать только один раз.  
**Нет изменения исходных данных** – `Stream` не изменяет коллекцию, а создаёт новую.  
**Порядок выполнения не гарантирован** – в `parallelStream()` порядок элементов может измениться.  
**Не все операции эффективны** – например, `sorted()` требует полного прохода по данным.  
**Исключения сложнее обрабатывать** – нет встроенной обработки `checked exceptions`.  
**Не всегда быстрее `for`-циклов** – из-за накладных расходов, особенно на малых данных.

---
### 80. Как передать переменную в стрим что с ней можно сделать

**Ответ:**

 **Передача переменной в `Stream API`:**  
**Через `map()`** – изменять и передавать новые значения (`map(n -> n * factor)`).  
**Через `filter()`** – использовать для условий (`filter(n -> n > threshold)`).  
**Через `forEach()`** – выполнять действия с внешней переменной.

 **Ограничения:**  
**Локальная переменная внутри лямбды должна быть `final` или `effectively final`**.  
**Для изменения значения используйте массивы, `AtomicInteger`, `List`, `Map` или `Collector`**.

---
### 81. Как создать Optional

**Ответ:**

 **Создание `Optional`:**  
`Optional.of(value)` – создаёт `Optional`, если `value` **не null** (иначе `NullPointerException`).  
`Optional.ofNullable(value)` – создаёт `Optional`, допускающий `null`.  
`Optional.empty()` – создаёт пустой `Optional`.

---
### 82. Отличие Optional of() nulable()

**Ответ:**

- **`Optional.of(value)`** – создаёт `Optional` с переданным значением, но **не допускает `null`** (бросает `NullPointerException`).

- **`Optional.ofNullable(value)`** – создаёт `Optional`, который может быть **пустым (`Optional.empty()`)**, если передано `null`.

---
### 83. В чем отличие методов ifPresent и orElse в контексте Optional?

**Ответ:**

 **`ifPresent(Consumer<T>)`** – выполняет действие, если значение присутствует.  
`optional.ifPresent(System.out::println);`

 **`orElse(T other)`** – возвращает значение, если оно есть, иначе возвращает `other`.  
`String result = optional.orElse("default");`

 **Разница:**  
`ifPresent()` выполняет **действие**, но не возвращает значение.  
`orElse()` возвращает **значение**, но не выполняет действия.

---
### 84. Каким образом можно объединить два Optional в один, используя метод join?

В `Optional` **нет метода `join()`**, но объединить два `Optional` можно так:

 **`flatMap()` + `or()`** – объединение, если оба значения присутствуют:  
`optional1.flatMap(value1 -> optional2.map(value2 -> value1 + value2))`.

 **`orElseGet()`** – использовать значение из второго `Optional`, если первый пуст:  
`optional1.or(() -> optional2)`.

---
### 85. Что проверяет ifPresent Optional?

**Ответ:**

 **`ifPresent(Consumer<T>)`** проверяет, **есть ли значение в `Optional`**.  
Если значение присутствует → выполняет переданное действие.  
Если `Optional` пуст → ничего не делает.

---
### 86. Каким образом можно преобразовать Stream в массив или коллекцию?

**Ответ:**

 **Преобразование `Stream` в массив:**  
`stream.toArray()` – создаёт массив `Object[]`.  
`stream.toArray(IntFunction<T[]>)` – создаёт массив указанного типа (`stream.toArray(String[]::new)`).

 **Преобразование `Stream` в коллекцию:**  
`stream.collect(Collectors.toList())` – в `List`.  
`stream.collect(Collectors.toSet())` – в `Set`.  
`stream.collect(Collectors.toMap(Function::apply, Function::apply))` – в `Map`.

---
### 87. В чём отличие методов orElseGet и orElse?

**Ответ:**

---
### 88. Каким образом можно реализовать обработку ошибок с использованием Optional и метод orElseThrow?

**Ответ:**

---
### 89. Как хэш SHA-1 используется в Git?

**Ответ**

___
### 90. Каковы основные состояния файла в Git?

**Ответ**

___
### 91. Команды git init, что создается. Как скопировать удаленную репу?

**Ответ**

___
### 92. Что происходит после создания коммита?

**Ответ**

___
### 93. Как добавить комит и зафиксировать его?

**Ответ**

___
### 94. Нужно ли отправлять коммиты на сервер для завершения рабочего процесса Git?

**Ответ**

___
### 95. Что происходит при git fetch

**Ответ**

___
### 96. Что происходит при git merge?

**Ответ**

___
### 97. Разрешает ли Git конфликты автоматически?

**Ответ**

___
### 98. Возможен git pull, если в файле в рабочем каталоге есть незафиксированные изменения?

**Ответ**

___
### 99. Что за команда git cherry pick (можно ли добавить несколько комитов)

**Ответ**

___
### 100. Какова цель указателя HEAD?

**Ответ**

___
### 101. В каких случаях возникает конфликт?

**Ответ**

___
### 102. Как изменить историю коммитов (rebase amend)?

**Ответ**

___
### 103. В чем разница между git merge и git rebase? О чем следует помнить при изменении истории веток?

**Ответ**

___
### 104. Как разрешать конфликты?

**Ответ**

___
### 105. Что такое «git remote» и «git clone»?

**Ответ**

___
### 106. Что такое detached HEAD?

**Ответ**

___
### 107. Варианты reset?

**Ответ**

___
### 108. Что такое git revert?

**Ответ**

___
### 109. Как снести удаленно ветку которую запушил?

**Ответ**

___